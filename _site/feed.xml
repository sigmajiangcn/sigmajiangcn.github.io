<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>进无止境</title>
    <description>专注数学，机器学习和数据挖掘应用
</description>
    <link>http://sigmajiangcn.github.io/</link>
    <atom:link href="http://sigmajiangcn.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 May 2020 09:40:15 +0800</pubDate>
    <lastBuildDate>Mon, 04 May 2020 09:40:15 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>6_ZigZagConversion</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion/description/&quot;&gt;之字形路线&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
P   A   H   N
A P L S I I G
Y   I   R
&lt;/code&gt;
And then read line by line: “PAHNAPLSIIGYIR”&lt;/p&gt;

&lt;p&gt;Write the code that will take a string and make this conversion given a number of rows:
Examples：
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3
Output: &quot;PAHNAPLSIIGYIR&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;PAYPALISHIRING&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numRows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;PINALSIGYAHRPI&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Explanation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路分析
参考这个&lt;a href=&quot;https://blog.csdn.net/qian2729/article/details/50507694&quot;&gt;实现方案&lt;/a&gt;，采用模拟之字路线图的方法解决问题。&lt;/p&gt;

&lt;p&gt;用一个数组来存储每一行的字符，用变量row来记录当前访问到的行，依次将字符串text中的字符放入不同的行，然后将所有行的字符串串联起来。
## 实际代码
Python
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
class Solution(object):
    def convert(self, s, numRows):
        &quot;&quot;&quot;
        :type s: str
        :type numRows: int
        :rtype: str
        &quot;&quot;&quot;
        if numRows == 1:
            return s
        zigzag = [&#39;&#39; for _ in range(numRows)]
        row = 0
        step = 1
        for c in s:
            if row == 0:
                step = 1
            if row == numRows - 1:
                step = -1
            zigzag[row] += c
            row += step
        return &#39;&#39;.join(zigzag)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C++
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
JAVA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GO
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

SCALA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路拓展&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 23:22:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-6_ZigZagConversion.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-6_ZigZagConversion.html</guid>
        
        
        <category>lettcode</category>
        
      </item>
    
      <item>
        <title>5_Longest Palindomic Substring</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;实际代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/description/&quot;&gt;最长回文子序列&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;

&lt;p&gt;Examples：
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cbbd&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bb&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路分析
参考这个&lt;a href=&quot;https://blog.csdn.net/fuxuemingzhu/article/details/79573621&quot;&gt;实现方案&lt;/a&gt;，采用动态规划的方法解决问题。&lt;/p&gt;

&lt;p&gt;动态规划的两个特点：第一大问题拆解为小问题，第二重复利用之前的计算结果。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fisherlei.blogspot.com/2012/12/leetcode-longest-palindromic-substring.html&quot;&gt;解题报告&lt;/a&gt;
指出存在$O(n)$&lt;a href=&quot;https://articles.leetcode.com/longest-palindromic-substring-part-ii/&quot;&gt;解法&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意下&lt;a href=&quot;https://www.cnblogs.com/woshare/p/5823303.html&quot;&gt;Python中定义二维数组的方法&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实际代码&lt;/h2&gt;
&lt;p&gt;Python
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
class Solution(object):
    def longestPalindrome(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        if len(set(s)) == 1:
            return s
        n = len(s)
        start, end, maxL = 0, 0, 0
        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(i):
                dp[j][i] = (s[j] == s[i]) &amp;amp; ((i - j &amp;lt; 2) | dp[j + 1][i - 1])
                if dp[j][i] and maxL &amp;lt; i - j + 1:
                    maxL = i - j + 1
                    start = j
                    end = i
            dp[i][i] = 1
        return s[start : end + 1]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C++
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
JAVA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GO
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

SCALA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路拓展&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 23:22:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-5_LongestPalindomicSubstring.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-5_LongestPalindomicSubstring.html</guid>
        
        
        <category>lettcode</category>
        
      </item>
    
      <item>
        <title>4_MedianofTwoSortedArrays</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;实际代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/description/&quot;&gt;两个有序数组的中值&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p&gt;

&lt;p&gt;Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;

&lt;p&gt;Examples：
```python
nums1 = [1, 3]
nums2 = [2]&lt;/p&gt;

&lt;p&gt;The median is 2.0
```&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nums1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nums2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;The&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;median&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路分析
参考这个&lt;a href=&quot;https://www.cnblogs.com/zuoyuan/p/3759682.html&quot;&gt;实现方案&lt;/a&gt;，采用递归的方法解决问题。关注递归结束的判别条件。得到一个第$k$大数字的普遍方法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实际代码&lt;/h2&gt;
&lt;p&gt;Python
```python
class Solution(object):
    def getKth(self,nums1, nums2,k):
        len1=len(nums1)
        len2=len(nums2)
        if len1&amp;gt;len2:
            return self.getKth(nums2,nums1,k)
        if len1==0:
            return nums2[k-1]
        if k==1:
            return min(nums1[0],nums2[0])
        pa=min(k/2,len1)
        pb=k-pa
        if nums1[pa-1]&amp;lt;=nums2[pb-1]:
            return self.getKth(nums1[pa:],nums2,pb)
        else:
            return self.getKth(nums1,nums2[pb:],pa)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def findMedianSortedArrays(self, nums1, nums2):
    &quot;&quot;&quot;
    :type nums1: List[int]
    :type nums2: List[int]
    :rtype: float
    &quot;&quot;&quot;
    len1=len(nums1)
    len2=len(nums2)
    if(len1+len2)%2==1:
        return self.getKth(nums1,nums2,(len1+len2)/2+1)
    else:
        return (self.getKth(nums1,nums2,(len1+len2)/2)+self.getKth(nums1,nums2,(len1+len2)/2+1))*0.5 ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C++
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
JAVA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GO
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

SCALA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路拓展
1.如果是两个无序数组？
## 总结
实际上是得到一个第$k$个大的数字的普遍方法。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 23:22:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-4_MedianofTwoSortedArrays.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-4_MedianofTwoSortedArrays.html</guid>
        
        
        <category>lettcode</category>
        
      </item>
    
      <item>
        <title>3_LongestSubStringWithoutRepeatingCharacter</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;思路分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;实际代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/description/&quot;&gt;最长无重复字符的子串&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;Examples：
```python
Given “abcabcbb”, the answer is “abc”, which the length is 3.&lt;/p&gt;

&lt;p&gt;Given “bbbbb”, the answer is “b”, with the length of 1.&lt;/p&gt;

&lt;p&gt;Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.
```&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;思路分析&lt;/h2&gt;
&lt;p&gt;参考使用&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1731/A-Python-solution-85ms-O(n)&quot;&gt;enumerate&lt;/a&gt;迭代字符串，一次遍历字符串，如果字符已经存在，则更新起点位置；否则更新当前最大长度。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实际代码&lt;/h2&gt;
&lt;p&gt;Python
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        start=0
        exist={}
        maxlen=0
        for i,c in enumerate(s):
            if(c in exist and exist[c]&amp;gt;=start):
                start=exist[c]+1
            else:
                maxlen=max(maxlen,i-start+1)
            exist[c]=i
        return maxlen
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C++
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
JAVA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GO
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

SCALA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路拓展
1.如果容许一个字符或者若干字符重复，则结果如何？
## 总结
一次遍历，充分利用了字典的查找效率。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 23:22:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-3_LongestSubStringWithoutRepeatingCharacter.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-3_LongestSubStringWithoutRepeatingCharacter.html</guid>
        
        
        <category>lettcode</category>
        
      </item>
    
      <item>
        <title>2_AddTwoNums</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;思路分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;实际代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/description//&quot;&gt;两个非负非空单链表表示的逆序整数之和&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;

&lt;p&gt;Examples：
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8
Explanation: 342 + 465 = 807.
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;思路分析&lt;/h2&gt;
&lt;p&gt;两个逆序整数链表求和，逆序链表的head是整数的低位，而两个整数相加本身就应该从低位相加。需要注意的是最后有可能有进位1.并且在初始化链表的表头以及最后返回时需要去掉表头。
从lettcode的耗时看，当前解法python耗时很高。后面需要继续优化。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实际代码&lt;/h2&gt;
&lt;p&gt;Python
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def &lt;strong&gt;init&lt;/strong&gt;(self, x):
#         self.val = x
#         self.next = None&lt;/p&gt;

&lt;p&gt;class Solution(object):
    def addTwoNumbers(self, l1, l2):
        “””
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        “””
        if(not l1):
            return l2
        if(not l2):
            return l1
        res=ListNode(0)
        head=res
        carry=0
        while(l1 or l2):
            sum=(l1.val if l1 else 0) +(l2.val if l2 else 0)+carry
            node=ListNode(sum%10)
            carry=sum/10
            res.next=node
            res=res.next
            if l1:
                l1=l1.next
            if l2:
                l2=l2.next
        if carry:
            res.next=ListNode(1)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    head=head.next
    return head ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C++
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
JAVA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GO
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

SCALA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路拓展
1.如果是两个逆序整数相乘法？
## 总结
表面是逆序整数相加的问题，实际上就是正常的两个数从低位相加的过程。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 23:22:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-2_AddTwoNumbers.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-2_AddTwoNumbers.html</guid>
        
        
        <category>lettcode</category>
        
      </item>
    
      <item>
        <title>多变量逻辑回归与竞争模型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;在品牌广告中，平台通常需要提供大量的剧目内容，例如电影、电视剧、综艺等。招商广告主在广告投放时希望指定若干，在同一个时期，可能会有多个剧目同时播放，在&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multinomial_logistic_regression&quot;&gt;Multinomial logistic regression&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Multinomial_probit&quot;&gt;Multinomial probit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;样例demo
```Python
#https://www.cnblogs.com/chenkuo/p/8087055.html
import tensorflow as tf
import numpy as np
from numpy.random import RandomState
batch_size = 8&lt;/p&gt;

&lt;p&gt;#假设是3维度，或者30，由样本特征维度决定
xa = tf.placeholder(tf.float32, shape=(None, 3), name=”xa-input”)
wa = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))
tempa=tf.exp(tf.matmul(xa,wa))&lt;/p&gt;

&lt;p&gt;xb = tf.placeholder(tf.float32, shape=(None, 3), name=”xb-input”)
wb = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))
tempb=tf.exp(tf.matmul(xb,wb))&lt;/p&gt;

&lt;p&gt;ya=tempa/(1+tempa+tempb)
yb=tempb/(1+tempa+tempb)&lt;/p&gt;

&lt;p&gt;ya_ = tf.placeholder(tf.float32, shape=(None, 1), name=”ya-input”)
yb_ = tf.placeholder(tf.float32, shape=(None, 1), name=”yb-input”)&lt;/p&gt;

&lt;p&gt;loss=tf.reduce_sum(-ya_&lt;em&gt;tf.log(ya)-yb_&lt;/em&gt;tf.log(yb))
train_step = tf.train.AdamOptimizer(0.001).minimize(loss)&lt;/p&gt;

&lt;p&gt;#通过随机数生成一个模拟数据集
rdma = RandomState(10)
rdmb = RandomState(20)
dataset_size = 128
Xa = rdma.rand(dataset_size, 3)
Xb = rdmb.rand(dataset_size, 3)&lt;/p&gt;

&lt;p&gt;Ya_temp = [[x1 + 5&lt;em&gt;x2+ 2&lt;/em&gt;x3 + rdma.rand()/10.0-0.05] for (x1, x2,x3) in Xa]
Yb_temp = [[2&lt;em&gt;x1 + 1&lt;/em&gt;x2+ 3*x3 + rdmb.rand()/10.0-0.05] for (x1, x2,x3) in Xb]&lt;/p&gt;

&lt;p&gt;#tensor can not be used in feed_dict
Ya=np.divide(np.exp(Ya_temp),1+np.exp(Ya_temp)+np.exp(Yb_temp))
Yb=np.divide(np.exp(Yb_temp),1+np.exp(Ya_temp)+np.exp(Yb_temp))&lt;/p&gt;

&lt;p&gt;with tf.Session() as sess:
	init = tf.global_variables_initializer()
	sess.run(init)
	steps = 50000
	for i in range(steps):
		start = (i * batch_size) % dataset_size
		end = min(start + batch_size, dataset_size)
		sess.run(train_step, feed_dict={xa:Xa[start:end], ya_:Ya[start:end],xb:Xb[start:end], yb_:Yb[start:end]})
		if i%1000==0:
			res=(sess.run(loss, feed_dict={xa:Xa[start:end], ya_:Ya[start:end],xb:Xb[start:end], yb_:Yb[start:end]}))
			print(i,res)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(sess.run([wa,wb]))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;’’’
48000 3.7348
49000 2.38889
[array([[ 1.32607698],
       [ 5.57283545],
       [ 2.3874886 ]], dtype=float32), array([[ 2.38537025],
       [ 1.29027772],
       [ 3.43826056]], dtype=float32)]
‘’’
```&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 21:34:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/strategy/2018/04/13/strategy-multiLR&Competition.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/strategy/2018/04/13/strategy-multiLR&Competition.html</guid>
        
        
        <category>strategy</category>
        
      </item>
    
      <item>
        <title>Explore&amp;Exploit</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#explore-and-exploit-ee&quot; id=&quot;markdown-toc-explore-and-exploit-ee&quot;&gt;探索与利用(Explore and exploit) E&amp;amp;E&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ee-ucb&quot; id=&quot;markdown-toc-ee-ucb&quot;&gt;E&amp;amp;E算法-UCB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;效果广告投放由于目标直接，通常吸引了大量的广告主，但是在中长尾的很多小广告主由于预算有限，素材一般或者其他原因，不一定能够得到曝光的机会；而持续消耗大广告主的预算也不具有持久性；为了丰富平台的多样性和收入稳定，Explore探索和exploit利用成为一个重要的流量分配探索策略。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dmlove/p/4972505.html&quot;&gt;E&amp;amp;E算法-UCB&lt;/a&gt;这篇文章写的比较通俗易懂，具有一定的高度。&lt;/p&gt;

&lt;h2 id=&quot;explore-and-exploit-ee&quot;&gt;探索与利用(Explore and exploit) E&amp;amp;E&lt;/h2&gt;
&lt;p&gt;关于E&amp;amp;E算法，我介绍两个基本思路，大家不要把它认为是一篇论文或是一个具体的算法，我介绍的是两个非常有借鉴意义的思路。这个领域大家比较认可的是UCB方法。&lt;/p&gt;

&lt;p&gt;点击率预测中还有一个重要的问题，就是探索与利用，它在工程中解决的并不好，我这章把现在论文中的常见的几种方法介绍一下。探索与利用它是所有互联网应用都要面对的一个问题，形式化一些，可以解释为：整体的效果是无法通过采样得到的，因为观察到的数据只是投放过的广告，而很多还没有投放的广告，想得到它们的效果，就很困难。&lt;/p&gt;

&lt;p&gt;计算广告领域的探索与利用要解决的问题是：因为长尾(a,u,c)组合极大部分在系统中并没有出现过，所以没有这些长尾(a,u,c)的统计量，所以要探索性地创造合适的展示机会以积累统计量，从而更准确地估计其CTR。但探索性的展示的过程是没有按当前的eCPM最大化方法进行广告投放，即探索的展示会让收入下降，那么如何控制探索的量和探索的有效性，使得系统长期的，整体的收入增加，就是探索与利用的核心问题。&lt;/p&gt;

&lt;p&gt;如果实践中做过广告系统，对于这一点应该有比较深的感触。因为无论是搜索广告，还是联盟广告，在广告主比较多的情况下，会有相当大的一批广告主是永远没有机会展示的，但我们也没有办法让他们得到一些展示的机会，因为要给他们展示的机会，是要付出相当大的代价的，有必要从算法的角度来讨论探索与利用的问题。Explore就是探索未知世界，Exploit就是利用从未知世界得到的少部分统计量，去提高eCPM统计的准确性。&lt;/p&gt;

&lt;p&gt;这个问题在学术界讨论的比较多，它是Reinforcement Learning中的一个具体问题，学术界通常把它描述成为一个Multi-arm Bandit(MAB)问题。这个名字的起源来自由laohuji上的扳手，扳哪个Arm赢的概率比较大，在开始的时候是不知道的，所以要用钱去探索，看哪个扳手能提供的收益最高，但试的过程是在损失自己的钱，所以用这个名字很形象地来称这个E&amp;amp;E问题。&lt;/p&gt;

&lt;p&gt;Multi-arm Bandit通常描述为：有限个arms(或称收益提供者)a（即上例中，laohuji的扳手是有限的，在广告系统中它就是广告），每个有确定有限的期望收益E(rt,a)，在每个时刻t，我们必须从arms中选择一个，最终目标是优化整体收益。MAB最基本的方法学术界称为ε-greedy，它是一个很简单的方法，就是将ε比例的小部分流量用于随机探索。如果提出一种新的E&amp;amp;E算法，当然首先要和这种方法进行比较。&lt;/p&gt;

&lt;p&gt;广告问题中有两个主要挑战，但它们不一定能很好地在这个框架下解决。1. 海量的组合空间需要被探索，因为要探索的是(a,u,c)这个组合空间，甚至不能认为是一个有限的空间（不是指数学上的无限），2. 因为在MAB问题中假设了各个arm的期望收益是确定的，但对于广告来讲，每个arm的收益绝对不是确定的，比如在双11促销前的ROI与其它时间的ROI相比，差的就很远了。这两个问题，我自己体会，在工程上需要研究者在以后进一步解决。&lt;/p&gt;

&lt;h2 id=&quot;ee-ucb&quot;&gt;E&amp;amp;E算法-UCB&lt;/h2&gt;
&lt;p&gt;UCB方法的思路从直觉上非常合理，它是在时间t，通过以往观测值以及某种概率模型，计算每个arm的期望收益的upper confidence bound(UCB)，并选择UCB最大的arm。先不关注这句话中的术语，它其实也是一个bayesian的理念，在估计某个arm收益的时候，不再把它认为是一个确定的数，而是把它认为是一个分布。UCB的意思是在选择的时候，并不是按照期望收益最大的一点去选择，而是按照分布的收益上界去选择。在体会这个策略的过程中，会发现它是一个很聪明的策略，它对每个arm都是选择它最有可能达到的收益点来进行投放，随着时间的推移，随着观察值的增加，分布曲线会越来越窄，最终收敛成一个固定的值。假设一个广告的期望收益并不高，换言之，它的表现可能不是最优的，我们在UCB方法下不会永远出这个广告，因为经过几次探索，它就分布曲线会迅速收敛，当发现有别的广告比它更好的时候，就不会再出这个广告了，但这种方法不会漏掉真正好的广告，因为好的广告在没有观察的时候，它是非常宽的一个函数分布，它的upper confidence是一个很大的值，所以总是有机会选中它，选中之后，分布会迅速收敛到实际的确定的收益。Paper中主要探讨的是具体的UCB策略，比如β-UCB策略，它是证明选择非最优的arms存在着一个上界，该上界与总的选择次数无关。还有一个改进的策略，UCB-tuned，它证明了如果已经选择的次数越多，就越可能自信地抛弃不太有前途（但仍可能最优）的arm。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基于贝叶斯的观点，结合先验和似然，得到后验。&lt;/li&gt;
  &lt;li&gt;具有分布的观点，置信上下界，假设一个宽分布，点击率不是一个绝对的数。&lt;/li&gt;
  &lt;li&gt;通过样本反馈，逐渐减小概率区间，分布趋窄。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 21:34:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/strategy/2018/04/13/strategy-Explore&Exploit.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/strategy/2018/04/13/strategy-Explore&Exploit.html</guid>
        
        
        <category>strategy</category>
        
      </item>
    
      <item>
        <title>1_TwoSum</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;思路分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;实际代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/description/&quot;&gt;寻找数组中满足指定和的两个数字&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;Examples：
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;思路分析&lt;/h2&gt;
&lt;p&gt;在一个数组中，寻找两个数字，以致于其和等于指定的结果。直接来看，仿佛需要两次遍历，判断数组中的数字两两之和是否满足条件，这样复杂度过高，为了简化，可以借用一个map，每次遍历一个数，都去map中查找指定结果与当前数的差值。如果找到，则结束，否则将当前数的值以及对应索引放进map。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实际代码&lt;/h2&gt;
&lt;p&gt;Python
&lt;code class=&quot;highlighter-rouge&quot;&gt;python
class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        res=[0,0]
        data={}
        for i,num in enumerate(nums):
            temp=target-num
            if temp in data:
                res[0]=data[temp]
                res[1]=i
                return res
            else:
                data[num]=i
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;C++
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
JAVA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GO
```code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;

SCALA
```code

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;## 思路拓展
1.如果目标是找出三个数，使得他们的和等于目标结果咧?即ThreeSum问题。
2.如果目标是找出两个数，使得他们的乘积等于目标结果咧？即TwoMultiply问题。
3.能找出所有满足条件的数之集合么？
## 总结
通过借用了map的数据结构完成了解答。&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Apr 2018 21:34:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-1_TwoSum.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/lettcode/2018/04/13/lettcode-1_TwoSum.html</guid>
        
        
        <category>lettcode</category>
        
      </item>
    
      <item>
        <title>凸优化</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;历史回顾&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;整体框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;描述统计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;推断统计&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;面向未来&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;很多现实问题都被建模为最优化问题，然后得到解决。这其中涉及到三个阶段：
- 无约束最优化
- 恒等式约束最优化
- 不等式约束最优化&lt;/p&gt;

&lt;p&gt;我们为什么要研究凸优化问题？为什么说凸优化问题重要？因为非凸的优化你能解决么？说到底，还是优化问题重要。只是，在现阶段，一个问题如果被定义成凸优化问题，则基本已经被解决了。另外，凸优化问题可能对偶问题和解析解。&lt;/p&gt;

&lt;p&gt;拉格朗日
kkt是什么东西
原始问题 对偶问题  kkt间隙
在线最优化求解方法  冯扬
在哪些典型业务和场景算法中应用
效果广告点击率
品牌广告库存分配
svm&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;历史回顾&lt;/h2&gt;

&lt;h2 id=&quot;section-2&quot;&gt;整体框架&lt;/h2&gt;

&lt;h2 id=&quot;section-3&quot;&gt;描述统计&lt;/h2&gt;

&lt;h2 id=&quot;section-4&quot;&gt;推断统计&lt;/h2&gt;

&lt;h2 id=&quot;section-5&quot;&gt;面向未来&lt;/h2&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Sun, 11 Mar 2018 10:32:28 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/math/2018/03/11/math-convex-optimization.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/math/2018/03/11/math-convex-optimization.html</guid>
        
        
        <category>math</category>
        
      </item>
    
      <item>
        <title>放眼未来之一:区块链</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;前言&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;回收硬盘空间&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;最近公司金融学院组织 《金融黑科技－与大牛一起解码区块链》，多位嘉宾针对区块链技术做了一些分享。思想碰撞，收获很多。&lt;/p&gt;

&lt;p&gt;与人工智能、云计算不同，区块链是最新十年来唯一诞生于&lt;strong&gt;草根&lt;/strong&gt;的重大技术。区块链是一种防篡改、共享的、可追溯的分布式账本技术（DLT）。比特币网络里，每十分钟诞生一个新的区块，区块里打包了网络里最近十分钟产生的交易。由某一个矿工做hash运算产生这个区块，通过共识算法，同步到其他矿工节点去。&lt;/p&gt;

&lt;p&gt;去年有些区块链相关的大会还需要嘉宾用一句话阐述区块链，说明区块链还处在概念澄清的阶段。但是很多颠覆性的革命技术，在指数式爆发之前，很多人高估了其短期的影响，而低估了长期的影响。&lt;/p&gt;

&lt;p&gt;区块链是一个能&lt;strong&gt;制造信用&lt;/strong&gt;的机器，是从&lt;strong&gt;信息&lt;/strong&gt;互联网转向&lt;strong&gt;价值&lt;/strong&gt;互联网的重要途径。下面以比特币作者&lt;strong&gt;Satoshi Nakamoto&lt;/strong&gt;的&lt;a href=&quot;https://bitcoin.org/bitcoin.pdf&quot;&gt;论文&lt;/a&gt;为核心，针对其关键技术进行分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;持续更新&lt;/strong&gt;
## 比特币
一种点对点的电子现金系统。完全点对点的电子现金系统可以不通过金融机构，由一方直接发送在线支付给另一方。
### 交易
我们将电子货币定义为一串由数字签名组成的链条。每一个电子货币的持有者通过下面的方式将它转移给下一位所有者：
- 对前一个交易和下一位所有者的公钥签署一个数字签名；
- 将这个签名附加在交易的末尾；
- 收款人通过验证签名，就可以验证电子货币的所有者链条。
### 时间戳服务器
时间戳服务器通过对交易事件构成的区块进行哈希计算，从而位区块打上时间戳，并且广播该哈希值。后续的时间戳都对之前的一个事件戳进行增强，从而形成了一个链条。
### 工作量证明
这是区块链分布式共识的共识。时间戳网络完成工作量证明的过程是：
- 在区块中添加一项随机数
- 变换随机数，直到找到一个值，使区块的哈希值出现被要求数目的零。&lt;/p&gt;

&lt;p&gt;目前有多种共识的，并不统一。
### 网络
节点总是认为最长链就是正确的链条，并持续在它的基础上工作以延长它。
### 激励&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回收硬盘空间&lt;/h3&gt;
&lt;p&gt;### 简化支付确认
### 价值的组合与分割
### 隐私
### 计算
$p=$ 诚实节点发现下一个区块的概率
$q=$ 攻击者发现下一个区块的概率
$q_z=$ 攻击者最终消弭了$z$ 个区块的落后差距
$q_z=$&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
q_z=
\begin{equation}  
\left\{  
             \begin{array}{lr}  
             1  ,p \leq q \\
             (q/p)^z,p&gt;q &amp;
      \end{array}
\right.  
\end{equation} %]]&gt;&lt;/script&gt;
## 量子计算
量子计算机如果打破了区块链的平衡后，应该怎么办？
### 总结
“工欲善其事，必先利其器”。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考文献&lt;/h2&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 28 Jan 2018 12:43:06 +0800</pubDate>
        <link>http://sigmajiangcn.github.io/future/2018/01/28/Future-Blockchain.html</link>
        <guid isPermaLink="true">http://sigmajiangcn.github.io/future/2018/01/28/Future-Blockchain.html</guid>
        
        
        <category>Future</category>
        
      </item>
    
  </channel>
</rss>
